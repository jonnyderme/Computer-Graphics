# -*- coding: utf-8 -*-
"""ComputerGraphics_Assignment_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TLg_gvcz7VMJIz9V3c_qFXu4GWVDkeBa

# **Libraries**
"""

import numpy as np
from matplotlib import pyplot as plt
import matplotlib.image as plt2
import time

"""# **Συναρτηση Γραμμικης Παρεμβολης**"""

def vector_interp(p1,p2,V1,V2,coord,dim):
    """""
    :parameter V1,V2: values of the vectors V1,V2
    :parameter p1,p2: coordinates of vectors V1,V2
    :parameter coord: takes the value of x or y, if dim = 1 or dim = 2
    :parameter dim: dimension along which the interpolation takes place
    :returns V: value of vector with coordinates x,y
    """""

    x1,y1 = p1
    x2,y2 = p2

    if dim == 1:
        x = coord
        if x > max(x1,x2):
            print("Given coordinates are not in range [x1,x2]")
            exit(1)
        if abs(x2-x1) < 1e-3:
            if abs(x-x1) < abs(x-x2):
                return x1
            else:
                return x2
        v1Coeff = np.abs(x2 - x) / np.abs(x2 - x1)
        v2Coeff = np.abs(x - x1) / np.abs(x2 - x1)
        V1 = np.array(V1)
        V2 = np.array(V2)
        V = V1*v1Coeff + V2*v2Coeff

        return V


    elif dim == 2:
        y = coord
        if y > max(y1,y2):
            print("Given coordinates are not in range [y1,y2]")
            exit(1)

        if abs(y2-y1) < 1e-3:
            if abs(y-y1) < abs(y-y2):
                return y1
            else:
                return y2
        v1Coeff = np.abs(y2 - y) / np.abs(y2 - y1)
        v2Coeff = np.abs(y - y1) / np.abs(y2 - y1)

        V1 = np.array(V1)
        V2 = np.array(V2)
        V = V1*v1Coeff + V2*v2Coeff

        return V

"""# **Βοηθητικες Συναρτησεις για Χαραξη γραμμων (Αλγοριθμος Bresenham)**"""

def bresenhamAlgorithm(vertexPoint1, vertexPoint2, axis):
    """""
    Implements the bresenham line drawing algorithm for two vertices
    :parameter vertexPoint1: coordinates [x,y] of vertex point 1
    :parameter vertexPoint2: coordinates [x,y] of vertex point 2
    :parameter axis: the axis along which the line is calculated
    :returns edgePixels: (M,2) array that contains the coordinates [x,y] of the pixels that belong to the line
    """""

    # Bresenham in y axis
    if axis == 1:
        # Find starting and ending point
        if vertexPoint1[1] <= vertexPoint2[1]:
            x0, y0 = vertexPoint1
            x1, y1 = vertexPoint2
        else:
            x0, y0 = vertexPoint2
            x1, y1 = vertexPoint1

        # Compute deltaX and deltaY
        deltaY = 2 * (y1 - y0)
        deltaX = 2 * np.abs(x1 - x0)
        f = -deltaX + deltaY / 2
        x = x0
        y = y0
        edgePixels = np.array([x, y])
        for y in range(y0 + 1, y1):
            if f < 0:
                if x0 < x1:
                    x = x + 1
                else:
                    x = x - 1
                f = f + deltaY
            f = f - deltaX
            edgePixels = np.vstack((edgePixels, np.array([x, y])))
        edgePixels = np.vstack((edgePixels, np.array([x1, y1])))

    # Bresenham in x axis
    elif axis == 0:
        # Find starting and ending point
        if vertexPoint1[0] < vertexPoint2[0]:
            x0, y0 = vertexPoint1
            x1, y1 = vertexPoint2
        else:
            x0, y0 = vertexPoint2
            x1, y1 = vertexPoint1

        # Compute deltaX and deltaY
        deltaX = 2 * (x1 - x0)
        deltaY = 2 * np.abs(y1 - y0)
        f = -deltaY + deltaX / 2
        x = x0
        y = y0
        edgePixels = np.array([x, y])
        for x in range(x0 + 1, x1):
            if f < 0:
                if y0 < y1:
                    y = y + 1
                else:
                    y = y - 1
                f = f + deltaX
            f = f - deltaY
            edgePixels = np.vstack((edgePixels, np.array([x, y])))
        edgePixels = np.vstack((edgePixels, np.array([x1, y1])))
    return edgePixels

def fillLine(vertexPoint1, vertexPoint2):
    """""
     Draws the line for two given vertices
    :param vertexpPoint1: coordinates [x,y] of vertex point 1
    :param vertexPoint2: coordinates [x,y] of vertex point 2
    :returns edgePoints: (M,2) array that contains the coordinates [x,y] of the pixels that belong to the line
    """""
    vertexPoint1 = np.array(vertexPoint1)
    vertexPoint2 = np.array(vertexPoint2)

    # If the two points are in the same line
    if vertexPoint1[0] == vertexPoint2[0]:
        x = vertexPoint1[0]
        start = min(vertexPoint1[1], vertexPoint2[1])
        end = max(vertexPoint1[1], vertexPoint2[1])

        edgePoints = np.array([x, start])
        for y in range(start + 1, end + 1):
            edgePoints = np.vstack((edgePoints, np.array([x, y])))

    # If the two points are in the same column
    if vertexPoint1[1] == vertexPoint2[1]:
        y = vertexPoint1[1]
        start = min(vertexPoint1[0], vertexPoint2[0])
        end = max(vertexPoint1[0], vertexPoint2[0])

        edgePoints = np.array([start, y])
        for x in range(start + 1, end + 1):
            edgePoints = np.vstack((edgePoints, np.array([x, y])))

    # If the two points are neither in the same column and line, perform bresenham in x or y axis, depending on the slope
    # If slope < 1 -> bresenham in y axis, else -> bresenham in x axis
    else:
        # Find slope
        slope = (vertexPoint1[0] - vertexPoint2[0]) / (vertexPoint2[1] - vertexPoint1[1])
        if np.abs(slope) < 1:
            # Bresenham in y axis (axis = 1)
            edgePoints = bresenhamAlgorithm(vertexPoint1, vertexPoint2, axis=1)
        else:
            # Bresenham in x axis
            edgePoints = bresenhamAlgorithm(vertexPoint1, vertexPoint2, axis=0)

    return edgePoints

"""# **Flat Shading**"""

def f_shading(img, vertices, vcolors):
    """""
    :img: the already existing image with its triangles
    :vertices: Integer array 3x2 that contains the coordinates of triangle's vertices in each line.
    :vcolors: Array 3x3 that contains the color of triangle's vertex in each line with RGB values[0,1]
    :updated_img: Array MxNx3 that contains the RGB values for all the parts of the
    :triangle and the already existing triangles
    :returns updated_img: MxNx3 array containing the RGB values for all the parts of the triangle and the already existing triangles
    """""

    # Initialize variables x_k_min, x_k_max, y_k_min, y_k_max for filling algorithm
    x_k_min = np.zeros(3)
    x_k_max = np.zeros(3)
    y_k_min = np.zeros(3)
    y_k_max = np.zeros(3)

    # Find the x_k_min, x_k_max, y_k_min, y_k_max for every edge
    for k in range(3):
        if k == 2:
            x_k_min[k] = min(vertices[k][0], vertices[k - 2][0])
            x_k_max[k] = max(vertices[k][0], vertices[k - 2][0])
            y_k_min[k] = min(vertices[k][1], vertices[k - 2][1])
            y_k_max[k] = max(vertices[k][1], vertices[k - 2][1])
        else:
            x_k_min[k] = min(vertices[k][0], vertices[k + 1][0])
            x_k_max[k] = max(vertices[k][0], vertices[k + 1][0])
            y_k_min[k] = min(vertices[k][1], vertices[k + 1][1])
            y_k_max[k] = max(vertices[k][1], vertices[k + 1][1])

    # The smallest ymin and the biggest ymax
    y_min = min(y_k_min)
    y_max = max(y_k_max)

    # Declare the coordinates of every vertex point
    vertexPoint1 = vertices[0]
    vertexPoint2 = vertices[1]
    vertexPoint3 = vertices[2]

    # Colors (RGB - Channels) for every vertex
    v1Color = vcolors[0]
    v2Color = vcolors[1]
    v3Color = vcolors[2]

    # Calculate the pixels of every edge including the coordinates of 2 vertices
    edge1 = fillLine(vertexPoint1, vertexPoint2)
    edge2 = fillLine(vertexPoint2, vertexPoint3)
    edge3 = fillLine(vertexPoint3, vertexPoint1)

    # Check if there is horizontal line on top or bottom
    topHorizontalLine = 0
    bottomHorizontalLine = 0

    if y_k_min[0] == y_k_min[1] and y_k_min[1] == y_k_min[2]:
        bottomHorizontalLine = 1

    if y_k_max[0] == y_k_max[1] and y_k_max[1] == y_k_max[2]:
        topHorizontalLine = 1

    # Sort the pixels of every edge
    if edge1.ndim > 1 :
       e1Ind = np.argsort(edge1[:,0])
       edge1 = edge1[e1Ind]
    else :
      edge1 = np.array([edge1])

    if edge2.ndim > 1 :
       e2Ind = np.argsort(edge2[:,0])
       edge2 = edge2[e2Ind]
    else :
       edge2 = np.array([edge2])

    if edge3.ndim > 1 :
       e3Ind = np.argsort(edge3[:,0])
       edge3 = edge3[e3Ind]
    else :
      edge3 = np.array([edge3])

    edge1 = list(edge1)
    edge2 = list(edge2)
    edge3 = list(edge3)

    # Find the average colors based on the colors of the triangle's vertices
    meanColor = [0, 0, 0]

    meanColor[0] = (vcolors[0][0] + vcolors[1][0] + vcolors[2][0])/ 3
    meanColor[1] = (vcolors[0][1] + vcolors[1][1] + vcolors[2][1])/ 3
    meanColor[2] = (vcolors[0][2] + vcolors[1][2] + vcolors[2][2])/ 3

    # Fill the pixels of every edge with the mean color of the triangle
    for point in edge1:
            img[point[1]][point[0]] = meanColor
    for point in edge2:
            img[point[1]][point[0]] = meanColor
    for point in edge3:
            img[point[1]][point[0]] = meanColor

    # Find bottom and top Scanline
    bottomScanline =  min(edge1[0][0], edge2[0][0], edge3[0][0])
    topScanline    =  max(edge1[-1][0], edge2[-1][0], edge3[-1][0])

    # Scanline Algorithm
    for scanline in range(bottomScanline, topScanline + 1):
        activePoints = []
        for point in edge1:
            if point[0] == scanline:
                activePoints.append(point)
        for point in edge2:
            if point[0] == scanline:
                activePoints.append(point)
        for point in edge3:
            if point[0] == scanline:
                activePoints.append(point)

         # If only one point is found (it will be a vertex--already colored), move to the next iteration
        if len(activePoints) == 1:
           continue
        else:
            # Find the minimum and maximum column indices among the active points
            min_col_active = np.array(activePoints).min(axis=0)[1]
            max_col_active = np.array(activePoints).max(axis=0)[1]

            # Fill the pixels between the minimum and maximum column indices with the mean color
            activePoints  =np.array(activePoints)
            for i in range(min_col_active, max_col_active):
              if np.array([i, scanline]) in activePoints:
                    if not np.allclose(img[i][scanline], meanColor):
                       img[i][scanline] = meanColor
                    continue
              else:
                  img[i][scanline] = meanColor

    updated_img = img
    return updated_img

"""# **Render Image**"""

def render_img( faces, vertices, vcolors, depth,shading):
    """""
    :canvas:   (M,N,3) array created below to represent the canvas
    :vertices: (K,2) array that contains the [x,y] coordinates of each vertix. K is the number of vertices
    :faces:    (L,3) array that contains 3 indexes to the vertices array that define the vertices of the triangles. L is the number of triangles
    :vcolors:  (K,3) array that contains the [r,g,b] values of each vertix. K is the number of vertices
    :depth:    (K,1) array that contains the depth values for each vertix. K is the number of vertices
    :shading: is equal either to "f" or "g" and specifies the shading method
    :returns img: the updated img after rendering
    """""

    # Set up canvas with white background and resolution 512x512
    M = 512
    N = 512
    img = [[[1.0 for i in range(3)] for j in range(M)] for k in range(N)]

    triangleColors = []
    triangleDepths = []

    # Iterate over each triangle in the mesh in order to find the mean deapth and sort the depths of triangles
    for triangle in faces:
        # Determine the index of the current triangle in the faces list
        index = faces.index(triangle)
        # Convert the vertices of the triangle to 2D coordinates
        faces[index] = [vertices[triangle[0]], vertices[triangle[1]], vertices[triangle[2]]]

         # Calculate the triangle depth as the mean of the depths of the vertices
        newDepth = (depth[triangle[0]] + depth[triangle[1]] + depth[triangle[2]]) / 3
        triangleColors.append([vcolors[triangle[0]], vcolors[triangle[1]], vcolors[triangle[2]]])
        triangleDepths.append(newDepth)

    zipped = zip(triangleDepths, faces, triangleColors)
    # Get the indexes after sorting the triangle depth array with descending order
    triangleDepths, faces, triangleColors = zip(*sorted(zipped, key=lambda x: -x[0]))

    # Paint the triangles with flat or gouraud method based on shading
    for triangle in faces:
      if shading == 'f'  :
         img = f_shading(img, triangle, triangleColors[faces.index(triangle)])
      elif shading == 'g' :
         img = g_shading(img, triangle, triangleColors[faces.index(triangle)])


    return img

"""# **Demo : Flat Shading**"""

# Load the data from hw1.py
start = time.time()
data = np.load('hw1.npy', allow_pickle=True)
vcolors = data[()]['vcolors'].tolist()
faces = data[()]['faces'].tolist()
depth = data[()]['depth'].tolist()
vertices = data[()]['vertices'].astype(int).tolist()
end = time.time()
print('Data management execution time : ', end - start)

# Render
start = time.time()
img = render_img(faces, vertices, vcolors, depth,'f')
end = time.time()
print('Rendering execution time : ', end - start)

plt.imshow(img, interpolation='nearest')
plt.title('Flat Shading')
plt.show()
plt2.imsave('shade_flat_Image.png',np.array(img))

"""# **Gouraud Shading**"""

def g_shading(img, vertices, vcolors):
    """""
    :img: the already existing image with its triangles
    :vertices: Integer array 3x2 that contains the coordinates of triangle's vertices in each line.
    :vcolors: Array 3x3 that contains the color of triangle's vertex in each line with RGB values[0,1]
    :updated_img: Array MxNx3 that contains the RGB values for all the parts of the
    :triangle and the already existing triangles
    :returns updated_img: MxNx3 array containing the RGB values for all the parts of the triangle and the already existing triangles
    """""

    # Initialize variables x_k_min, x_k_max, y_k_min, y_k_max for filling algorithm
    x_k_min = np.zeros(3)
    x_k_max = np.zeros(3)
    y_k_min = np.zeros(3)
    y_k_max = np.zeros(3)

    # Find the x_k_min, x_k_max, y_k_min, y_k_max for every edge
    for k in range(3):
        if k == 2:
            x_k_min[k] = min(vertices[k][0], vertices[k - 2][0])
            x_k_max[k] = max(vertices[k][0], vertices[k - 2][0])
            y_k_min[k] = min(vertices[k][1], vertices[k - 2][1])
            y_k_max[k] = max(vertices[k][1], vertices[k - 2][1])
        else:
            x_k_min[k] = min(vertices[k][0], vertices[k + 1][0])
            x_k_max[k] = max(vertices[k][0], vertices[k + 1][0])
            y_k_min[k] = min(vertices[k][1], vertices[k + 1][1])
            y_k_max[k] = max(vertices[k][1], vertices[k + 1][1])

    # The smallest ymin and the biggest ymax
    y_min = min(y_k_min)
    y_max = max(y_k_max)

    # Declare the coordinates of every vertex point
    vertexPoint1 = vertices[0]
    vertexPoint2 = vertices[1]
    vertexPoint3 = vertices[2]

    # Colors (RGB - Channels) for every vertex
    v1Color = vcolors[0]
    v2Color = vcolors[1]
    v3Color = vcolors[2]

    # Calculate the pixels of every edge including the coordinates of 2 vertices
    edge1 = fillLine(vertexPoint1, vertexPoint2)
    edge2 = fillLine(vertexPoint2, vertexPoint3)
    edge3 = fillLine(vertexPoint3, vertexPoint1)

    # Check if there is horizontal line on top or bottom
    topHorizontalLine = 0
    bottomHorizontalLine = 0

    if y_k_min[0] == y_k_min[1] and y_k_min[1] == y_k_min[2]:
        bottomHorizontalLine = 1

    if y_k_max[0] == y_k_max[1] and y_k_max[1] == y_k_max[2]:
        topHorizontalLine = 1

    # Sort the pixels of every edge
    if edge1.ndim > 1 :
       e1Ind = np.argsort(edge1[:,0])
       edge1 = edge1[e1Ind]
    else :
      edge1 = np.array([edge1])

    if edge2.ndim > 1 :
       e2Ind = np.argsort(edge2[:,0])
       edge2 = edge2[e2Ind]
    else :
       edge2 = np.array([edge2])

    if edge3.ndim > 1 :
       e3Ind = np.argsort(edge3[:,0])
       edge3 = edge3[e3Ind]
    else :
      edge3 = np.array([edge3])

    edge1 = list(edge1)
    edge2 = list(edge2)
    edge3 = list(edge3)

    for point in edge1:
             # Check if the current point is a vertex of the triangle
            vertBool = False
            for vert in vertices:
               if np.array_equal(point,vert) :
                  vertBool = False
               else :
                   vertBool = True

            if  vertBool :
                # If gradient > 1
                if abs(vertices[0][0] - vertices[1][0]) > abs(vertices[0][1] - vertices[1][1]):
                    img[point[1]][point[0]] = vector_interp(vertices[0], vertices[1], v1Color, v2Color, point[0], dim=1)
                else:
                    img[point[1]][point[0]] = vector_interp(vertices[0], vertices[1], v1Color, v2Color, point[1], dim=2)
            else:
                  verticesList = list(vertices)
                  index = verticesList.index(list(point))
                  img[point[1]][point[0]] = vcolors[index]


    for point in edge2:
           vertBool = False
           for vert in vertices:
               if np.array_equal(point,vert) :
                  vertBool = False
               else :
                   vertBool = True

           if vertBool :
                # If gradient > 1
                if abs(vertices[1][0] - vertices[2][0]) > abs(vertices[1][1] - vertices[2][1]):
                    img[point[1]][point[0]] = vector_interp(vertices[1], vertices[2], v2Color, v3Color, point[0], dim = 1)
                else:
                    img[point[1]][point[0]] = vector_interp(vertices[1], vertices[2], v2Color, v3Color, point[1], dim = 2)
           else:
                verticesList = list(vertices)
                index = verticesList.index(list(point))
                img[point[1]][point[0]] = vcolors[index]


    for point in edge3:
           vertBool = False
           for vert in vertices :
               if np.array_equal(point,vert) :
                  vertBool = False
               else :
                   vertBool = True

           if vertBool :
                if abs(vertices[2][0] - vertices[0][0]) > abs(vertices[2][1] - vertices[0][1]):
                    # If gradient > 1
                    img[point[1]][point[0]] = vector_interp(vertices[2], vertices[0], v3Color, v1Color, point[0], dim = 1)
                else:
                    img[point[1]][point[0]] = vector_interp(vertices[2], vertices[0], v3Color, v1Color, point[1], dim = 2)
            #c)
           else:
                verticesList = list(vertices)
                index = verticesList.index(list(point))
                img[point[1]][point[0]] = vcolors[index]



    # Find bottom and top Scanline
    bottomScanline =  min(edge1[0][0], edge2[0][0], edge3[0][0])
    topScanline    =  max(edge1[-1][0], edge2[-1][0], edge3[-1][0])

    #lista energwn shmeiwn kai ananewsh auths se ka8e nea grammh sarwshs
    for scanline in range(bottomScanline, topScanline + 1):
        activePoints = []
        for point in edge1:
            if point[0] == scanline:
                activePoints.append(point)
        for point in edge2:
            if point[0] == scanline:
                activePoints.append(point)
        for point in edge3:
            if point[0] == scanline:
                activePoints.append(point)

        #an brw koryfh tote paw sthn epomenh epanalhpsh
        if len(activePoints) == 1:
            continue
        else:
            #apo thn lista energwn shmeiwn pairnw thn elaxisth timh kata sthlh
            min_col_active = np.array(activePoints).min(axis=0)[1]

            #apo thn lista energwn shmeiwn pairnw thn megisth timh kata sthlh
            max_col_active = np.array(activePoints).max(axis=0)[1]

            #zwgrafise ta energa shmeia metaksy twn oriakwn sthlwn
            activePoints  =np.array(activePoints)
            for i in range(min_col_active, max_col_active):
              if np.array([i, scanline]) in activePoints :
                    img[i][scanline] = vector_interp([min_col_active,scanline], [max_col_active,scanline] ,
                                                           img[min_col_active][scanline], img[max_col_active][scanline], i, dim=1)
                    continue
              else:
                  img[i][scanline] = vector_interp([min_col_active,scanline], [max_col_active,scanline] ,
                                                           img[min_col_active][scanline], img[max_col_active][scanline], i, dim=1)


    updated_img = img
    return updated_img

"""# **Demo : Gouraud Shading**"""

# Load the data from hw1.py
start = time.time()
data = np.load('hw1.npy', allow_pickle=True)
vcolors = data[()]['vcolors'].tolist()
faces = data[()]['faces'].tolist()
depth = data[()]['depth'].tolist()
vertices = data[()]['vertices'].astype(int).tolist()
end = time.time()
print('Data management execution time : ', end - start)

# Render
start = time.time()
img = render_img(faces, vertices, vcolors, depth,'g')
end = time.time()
print('Rendering execution time : ', end - start)

plt.imshow(img, interpolation='nearest')
plt.title('Gouraud Shading')
plt.show()
plt2.imsave('shade_gouraud_Image.png',np.array(img))
